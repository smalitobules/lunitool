use anyhow::{anyhow, Result};
use fluent_bundle::{FluentArgs, FluentResource, concurrent::FluentBundle as ConcurrentFluentBundle};
use unic_langid::{LanguageIdentifier, langid};
use std::collections::HashMap;
// fs, io::Read, and path::Path are no longer needed for loading resources from files here
use std::sync::Mutex;

// This will include the function generated by build.rs
// The path is relative to the crate root, pointing to a file in OUT_DIR.
include!(concat!(env!("OUT_DIR"), "/embedded_locales.rs"));

const DEFAULT_LOCALE: LanguageIdentifier = langid!("en");
const SUPPORTED_LOCALES: &[LanguageIdentifier] = &[
    langid!("en"),
    langid!("de"),
    // Add more language IDs here if you want to activate them.
    // The build script will embed all .ftl files it finds in src/locales,
    // but only those listed here will be actively loaded into BUNDLES.
];

lazy_static::lazy_static! {
    static ref BUNDLES: Mutex<HashMap<LanguageIdentifier, ConcurrentFluentBundle<FluentResource>>> = Mutex::new(load_all_bundles());
    static ref CURRENT_LOCALE: Mutex<LanguageIdentifier> = Mutex::new(DEFAULT_LOCALE.clone());
}

// load_fluent_resource function is no longer needed as resources are embedded.

fn load_all_bundles() -> HashMap<LanguageIdentifier, ConcurrentFluentBundle<FluentResource>> {
    let mut bundles = HashMap::new();
    let embedded_ftl_strings = get_embedded_ftl_strings(); // This function is from the auto-generated embedded_locales.rs

    for locale_id in SUPPORTED_LOCALES {
        let lang_code_str = locale_id.language.as_str();

        if let Some(ftl_string) = embedded_ftl_strings.get(lang_code_str) {
            match FluentResource::try_new(ftl_string.to_string()) { // .to_string() as try_new expects an owned String
                Ok(resource) => {
                    let mut bundle = ConcurrentFluentBundle::new_concurrent(vec![locale_id.clone()]);
                    if bundle.add_resource(resource).is_err() {
                        log::error!("Failed to add embedded resource for locale: {}", locale_id);
                    }
                    bundles.insert(locale_id.clone(), bundle);
                }
                Err(parse_errors) => {
                    log::error!("Failed to parse embedded FTL resource for locale {}: {:?}", locale_id, parse_errors);
                }
            }
        } else {
            // This warning is important if a locale is supported but its .ftl was not found/embedded.
            log::warn!("Locale '{}' is in SUPPORTED_LOCALES but no corresponding .ftl file was found by the build script or it failed to embed.", locale_id);
        }
    }

    // Check if the default locale was actually loaded
    if bundles.get(&DEFAULT_LOCALE).is_none() && SUPPORTED_LOCALES.contains(&DEFAULT_LOCALE) {
        log::warn!("Default locale '{}' is supported and should have been embedded, but was not found in loaded BUNDLES. Translations may not work as expected.", DEFAULT_LOCALE);
    } else if !SUPPORTED_LOCALES.contains(&DEFAULT_LOCALE) && !SUPPORTED_LOCALES.is_empty(){
        log::warn!("Default locale '{}' is not listed in SUPPORTED_LOCALES. Fallback translations might not function correctly.", DEFAULT_LOCALE);
    }
    bundles
}

/// Set the current language.
pub fn set_language(lang_code: &str) -> Result<()> {
    let target_locale: LanguageIdentifier = lang_code.parse()
        .map_err(|e| anyhow!("Failed to parse language code '{}': {}", lang_code, e))?;

    // Check if the target_locale is in SUPPORTED_LOCALES before trying to lock BUNDLES
    if !SUPPORTED_LOCALES.contains(&target_locale) {
        return Err(anyhow!("Unsupported language: {}. Not in SUPPORTED_LOCALES list.", lang_code));
    }

    let bundles_map = BUNDLES.lock().unwrap();
    if !bundles_map.contains_key(&target_locale) {
        // This case should ideally not be hit if SUPPORTED_LOCALES is managed correctly
        // and the build script + load_all_bundles work as expected for those locales.
        return Err(anyhow!("Unsupported language: {}. Not found in available (loaded) bundles, though it was in SUPPORTED_LOCALES.", lang_code));
    }

    let mut current_locale_lock = CURRENT_LOCALE.lock().unwrap();
    *current_locale_lock = target_locale;
    log::info!("Language set to: {}", lang_code);
    Ok(())
}

/// Get a translated string by key using Fluent.
pub fn get_text(key: &str) -> String {
    get_text_with_args(key, None)
}

/// Get a translated string by key with arguments using Fluent.
pub fn get_text_with_args(key: &str, args: Option<&FluentArgs>) -> String {
    let locale = CURRENT_LOCALE.lock().unwrap().clone();
    let bundles_guard = BUNDLES.lock().unwrap();

    let mut found_translation = false;
    let mut translated_value = String::new();

    // Try current locale
    if let Some(bundle) = bundles_guard.get(&locale) {
        if let Some(msg) = bundle.get_message(key) {
            if let Some(pattern) = msg.value() {
                let mut errors = Vec::new();
                translated_value = bundle.format_pattern(pattern, args, &mut errors).into_owned();
                if errors.is_empty() {
                    found_translation = true;
                } else {
                    log::warn!("Fluent formatting errors for key '{}' in locale '{}': {:?}", key, locale, errors);
                }
            }
        }
    }

    // Fallback to default locale if not found in current
    if !found_translation && locale != DEFAULT_LOCALE {
        if let Some(default_bundle) = bundles_guard.get(&DEFAULT_LOCALE) {
            if let Some(msg) = default_bundle.get_message(key) {
                if let Some(pattern) = msg.value() {
                    let mut errors = Vec::new();
                    translated_value = default_bundle.format_pattern(pattern, args, &mut errors).into_owned();
                    if errors.is_empty() {
                        found_translation = true;
                    } else {
                        log::warn!("Fluent formatting errors for key '{}' in fallback locale '{}': {:?}", key, DEFAULT_LOCALE, errors);
                    }
                }
            }
        } else if SUPPORTED_LOCALES.contains(&DEFAULT_LOCALE) {
            // Default locale is supported but bundle wasn't found
            log::warn!("Default locale '{}' is supported, but its bundle was not found for fallback translation of key '{}'.", DEFAULT_LOCALE, key);
        }
    }
    
    // If still not found, or if bundles themselves were missing (critical error)
    if !found_translation {
        if !bundles_guard.contains_key(&locale) && 
           (locale == DEFAULT_LOCALE || !bundles_guard.contains_key(&DEFAULT_LOCALE)) {
             log::error!("Neither current locale '{}' nor default locale '{}' (if different) bundle is available. Cannot translate key '{}'.", locale, DEFAULT_LOCALE, key);
        } else if !bundles_guard.contains_key(&locale) && locale != DEFAULT_LOCALE {
            log::warn!("Current locale '{}' not found in bundles. Fallback to default '{}' also failed for key '{}' or key not present in default.", locale, DEFAULT_LOCALE, key);
        } else {
            log::warn!("Translation key '{}' not found in locale '{}' or fallback '{}'. Returning key.", key, locale, DEFAULT_LOCALE);
        }
        return key.to_string(); // Return the key itself
    }

    translated_value
}

// The function `create_language_file` is removed as it's specific to the old FTL placeholder logic
// and not directly needed for Fluent, which loads .ftl files directly.
// If a mechanism to create template .ftl files is desired, it should be a separate utility or build script step.